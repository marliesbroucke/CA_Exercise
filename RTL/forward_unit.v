//Module: ALU
//Function: The ALU is a combinational circuit that executes the arithmetic or logical operation taking into account the control signals and input operands.
//Inputs:
//alu_in_0 (16 bits):  First operand
//alu_in_1 (16 bits): Second operand
//alu_ctrl (4 bits): Signal generated by the control unit to select one of the artihmetic or logical operations.
//shf_amnt (5 bits): Number of bits to shift for a shift instruction.
//Outputs:
//alu_out (16 bits): Result of the arithmetic or logical operation.
//zero_flag: If the result of the ALU is zero this signal is asserted.


module forward_unit#(
   parameter integer DATA_W     = 16
   )(
      input  wire signed        reg_write_MEM,
      input  wire signed        reg_write_WB, //are these needed?
      input  wire signed [4:0]  regfile_waddr_MEM,
      input  wire signed [4:0]  regfile_waddr_WB,
      input  wire signed [4:0]  read_reg_1,    //these are from the inputs of regfile right?
      input  wire signed [4:0]  read_reg_2,
      output reg signed [1:0]  top_select,
      output reg signed [1:0]  bot_select
   );
   
   //book page 319-320

   always@(*) begin
   // start with no hazard, if hazard signal will be overwritten

   top_select = 2'b00; //if no hazards just use regular output
   bot_select = 2'b00; //if no hazards just use regular output


   // execution hazard
   if ((reg_write_MEM == 1'b1) && (regfile_waddr_MEM == read_reg_1)) 
   
   begin
      top_select == 2'b10
   end

   if (reg_write_MEM == 1'b1 && (regfile_waddr_MEM == read_reg_2)) 

   begin
      bot_select = 2'b10;
   end  


   //MEM hazard

   if (reg_write_WB == 1'b1 &&! ( reg_write_MEM == 1'b1 && (regfile_waddr_MEM !== read_reg_1))  //and not statement
       && (regfile_waddr_WB == read_reg_1)) //reg adress must also match!
       
   begin 
      top_select = 2'b01;
   end 

   if (reg_write_WB == 1'b1 && !(reg_write_MEM == 1'b1 && (regfile_waddr_MEM !== read_reg_2))
       && (regfile_waddr_WB == read_reg_2)) 
      
   begin 
      bot_select = 2'b01;
   end 
      
   

   end
endmodule



